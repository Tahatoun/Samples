public class LoggingDecorator<T> : DispatchProxy
{
    private T _decorated = default!;
    private ILogger<T> _logger = default!;

    public static T Create(T decorated, ILogger<T> logger)
    {
        object proxy = Create<T, LoggingDecorator<T>>();
        ((LoggingDecorator<T>)proxy)._decorated = decorated;
        ((LoggingDecorator<T>)proxy)._logger = logger;
        return (T)proxy;
    }

    protected override object? Invoke(MethodInfo? targetMethod, object?[]? args)
    {
        if (targetMethod == null) return null;

        try
        {
            _logger.LogInformation("‚û°Ô∏è Appel {Method} avec args {@Args}",
                targetMethod.Name, args);

            var result = targetMethod.Invoke(_decorated, args ?? Array.Empty<object?>());

            if (result is Task task)
            {
                return InterceptAsync(task, targetMethod);
            }

            _logger.LogInformation("‚¨ÖÔ∏è Retour de {Method} = {@Result}",
                targetMethod.Name, result);

            return result;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "‚ùå Exception dans {Method}", targetMethod.Name);
            throw;
        }
    }

    private async Task InterceptAsync(Task task, MethodInfo targetMethod)
    {
        try
        {
            await task.ConfigureAwait(false);
            _logger.LogInformation("‚¨ÖÔ∏è Task {Method} termin√©e", targetMethod.Name);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "‚ùå Exception dans {Method}", targetMethod.Name);
            throw;
        }
    }
}

using Scrutor;

var builder = WebApplication.CreateBuilder(args);

// üîπ Scanner tous les services m√©tiers
builder.Services.Scan(scan => scan
    .FromAssemblyOf<IMyService>()                // met une classe de r√©f√©rence de ton assembly
    .AddClasses(classes => classes.InNamespaces("MonProjet.Services"))
        .AsImplementedInterfaces()
        .WithScopedLifetime()
);

// üîπ Appliquer le d√©corateur Logging √† toutes les interfaces
builder.Services.Decorate(typeof(object), (inner, provider) =>
{
    var innerType = inner.GetType().GetInterfaces().FirstOrDefault();
    if (innerType == null) return inner; // s√©curit√©

    var loggerType = typeof(ILogger<>).MakeGenericType(innerType);
    var logger = (ILogger)provider.GetRequiredService(loggerType);

    var method = typeof(LoggingDecorator<>)
        .MakeGenericType(innerType)
        .GetMethod("Create", BindingFlags.Public | BindingFlags.Static);

    return method!.Invoke(null, new[] { inner, logger });
});

// R√©cup√©rer tous les services enregistr√©s
var servicesToDecorate = builder.Services
    .Where(d => d.ServiceType.IsInterface && d.ImplementationType != null)
    .ToList();

foreach (var service in servicesToDecorate)
{
    builder.Services.Decorate(service.ServiceType, (inner, provider) =>
    {
        var loggerType = typeof(ILogger<>).MakeGenericType(service.ServiceType);
        var logger = provider.GetRequiredService(loggerType);

        var method = typeof(LoggingDecorator<>)
            .MakeGenericType(service.ServiceType)
            .GetMethod("Create", BindingFlags.Public | BindingFlags.Static);

        return method!.Invoke(null, new[] { inner, logger })!;
    });
}