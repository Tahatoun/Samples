using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace PipelineSample
{
    // 🔹 Niveau de gravité des erreurs
    public enum ErrorSeverity
    {
        Warning,
        Error,
        Critical
    }

    // 🔹 Structure typée d’une erreur
    public record Error(string Code, string Message, string? Step = null, ErrorSeverity Severity = ErrorSeverity.Error);

    // 🔹 Résultat d'une exécution de step (pattern Result monadique)
    public class Result<T>
    {
        public T? Value { get; }
        public List<Error> Errors { get; } = new();

        public bool IsSuccess => !Errors.Any(e => e.Severity is ErrorSeverity.Error or ErrorSeverity.Critical);

        private Result(T? value, IEnumerable<Error> errors)
        {
            Value = value;
            Errors.AddRange(errors);
        }

        public static Result<T> Success(T value) => new(value, Array.Empty<Error>());

        public static Result<T> Failure(IEnumerable<Error> errors) => new(default, errors);

        public static Result<T> From(T value, IEnumerable<Error> errors) => new(value, errors);

        public void AddError(Error error) => Errors.Add(error);

        public void AddErrors(IEnumerable<Error> errors) => Errors.AddRange(errors);
    }

    // 🔹 Contrat de step
    public interface IStep<T>
    {
        Task<Result<T>> ExecuteAsync(T input, CancellationToken cancellationToken = default);
    }

    // 🔹 Exemple de step de validation
    public class ValidationStep : IStep<InputContext>
    {
        public Task<Result<InputContext>> ExecuteAsync(InputContext input, CancellationToken cancellationToken = default)
        {
            var errors = new List<Error>();

            if (string.IsNullOrWhiteSpace(input.Tenor))
                errors.Add(new Error("TENOR_MISSING", "Le champ Tenor est requis", "ValidationStep"));

            if (input.MaturityDate < DateTime.Today)
                errors.Add(new Error("INVALID_DATE", "La date de maturité est dans le passé", "ValidationStep"));

            return Task.FromResult(Result<InputContext>.From(input, errors));
        }
    }

    // 🔹 Le moteur de pipeline
    public class PipelineExecutor<T>
    {
        private readonly List<IStep<T>> _steps;

        public PipelineExecutor(IEnumerable<IStep<T>> steps)
        {
            _steps = steps.ToList();
        }

        public async Task<Result<T>> RunAsync(T initialInput, CancellationToken cancellationToken = default)
        {
            var currentInput = initialInput;
            var allErrors = new List<Error>();

            foreach (var step in _steps)
            {
                var result = await step.ExecuteAsync(currentInput, cancellationToken);
                allErrors.AddRange(result.Errors);

                if (!result.IsSuccess)
                    break;

                currentInput = result.Value!;
            }

            return Result<T>.From(currentInput, allErrors);
        }
    }

    // 🔹 Le modèle d'entrée pour les steps
    public class InputContext
    {
        public string Tenor { get; set; } = string.Empty;
        public DateTime MaturityDate { get; set; }
    }

    // 🔹 Exemple de simulation d'utilisation
    public static class Program
    {
        public static async Task Main()
        {
            var steps = new List<IStep<InputContext>>
            {
                new ValidationStep()
                // Tu peux ajouter d'autres steps ici
            };

            var pipeline = new PipelineExecutor<InputContext>(steps);

            var input = new InputContext
            {
                Tenor = "", // volontairement vide pour déclencher une erreur
                MaturityDate = DateTime.Today.AddDays(-1) // date invalide
            };

            var result = await pipeline.RunAsync(input);

            if (!result.IsSuccess)
            {
                Console.WriteLine("❌ Erreurs détectées :");
                foreach (var group in result.Errors.GroupBy(e => e.Step ?? "UnknownStep"))
                {
                    Console.WriteLine($"- Étape : {group.Key}");
                    foreach (var error in group)
                        Console.WriteLine($"   • [{error.Code}] {error.Message} (Gravité : {error.Severity})");
                }
            }
            else
            {
                Console.WriteLine("✅ Pipeline exécuté avec succès !");
            }
        }
    }
}